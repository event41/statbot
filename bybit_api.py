# bybit_api.py# -*- coding: utf-8 -*-import timeimport hmacimport hashlibimport requestsfrom config import BOT_CREDENTIALSdef get_recent_trades(bot_id="CB-1", days=90):    url = "https://api.bybit.com/v5/execution/list"    recv_window = 5000    timestamp = str(int(time.time() * 1000))    # Проверяем, есть ли такой бот в конфиге    bot = BOT_CREDENTIALS.get(bot_id)    if not bot:        print(f"❌ Бот {bot_id} не найден в конфиге")        return []    api_key = bot["api_key"]    secret_key = bot["secret_key"]    # Начальное время (Unix Time в мс)    start_time_ms = int((time.time() - days * 86400) * 1000)    params = {        "category": "linear",        "limit": 200,        "startTime": start_time_ms    }    # Формируем строку для подписи    sorted_params = "&".join([f"{k}={v}" for k, v in sorted(params.items())])    param_str = f"{timestamp}{api_key}{recv_window}{sorted_params}"    signature = hmac.new(secret_key.encode("utf-8"), param_str.encode("utf-8"), hashlib.sha256).hexdigest()    headers = {        'X-BAPI-API-KEY': api_key,        'X-BAPI-SIGN': signature,        'X-BAPI-TIMESTAMP': timestamp,        'X-BAPI-RECV-WINDOW': str(recv_window),        'Content-Type': 'application/json'    }    all_trades = []    next_cursor = ''    page = 1    while True:        print(f"\n🔄 Запрос к Bybit (страница {page})...")        response = requests.get(url, headers=headers, params=params)        try:            data = response.json()        except ValueError:            print("❌ Не удалось распарсить JSON:", response.text[:500])            break        if data.get('retCode') != 0:            print(f"❌ Ошибка от Bybit: {data.get('retMsg')}")            break        result_list = data['result'].get('list', [])        all_trades.extend(result_list)        next_cursor = data['result'].get('nextPageCursor')        print(f"✅ Получено сделок (страница {page}): {len(result_list)}")        if not next_cursor or len(result_list) < params['limit']:            break        params['pageToken'] = next_cursor        page += 1    print(f"📥 Всего сделок для {bot_id}: {len(all_trades)}")    return parse_trades(all_trades, bot_id)def parse_trades(raw_trades, bot_id):    """    Парсим сырые данные из Bybit API и возвращаем список сделок с нужными полями    """    parsed = []    positions = {}  # Для учёта открытых позиций по символам    for trade in raw_trades:        exec_time_ms = trade.get("execTime")        exec_id = trade.get("execId")        symbol = trade.get("symbol")        side = trade.get("side")        qty = float(trade.get("execQty", 0))        price = float(trade.get("execPrice", 0))        profit = float(trade.get("closedPnl", 0))  # Прибыль по закрытой сделке        # Если нет closedPnl → рассчитываем самостоятельно        if profit == 0 and side == "Sell":            buys = positions.get(symbol, [])            if buys:                avg_buy_price = sum(b["price"] * b["qty"] for b in buys) / sum(b["qty"] for b in buys)                profit = round((price - avg_buy_price) * qty, 2)            positions[symbol] = []  # Очищаем после Sell        elif side == "Buy":            positions.setdefault(symbol, []).append({"price": price, "qty": qty})        # Конвертируем время из миллисекунд в секунды        timestamp = int(exec_time_ms) // 1000 if exec_time_ms else int(time.time())        parsed.append({            "bot_id": bot_id,            "exec_id": exec_id,            "symbol": symbol,            "side": side,            "qty": qty,            "price": price,            "profit": profit,            "timestamp": timestamp        })    print(f"🧮 Сделки успешно обработаны для {bot_id}: {len(parsed)}")    return parsed